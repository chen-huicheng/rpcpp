//
// Created by frank on 18-1-24.
//

#include "ClientStubGenerator.h"

using namespace jrpc;

namespace
{

std::string clientStubTemplate(
        const std::string& macroName,
        const std::string& stubClassName,
        const std::string& procedureDefinitions,
        const std::string& notifyDefinitions)
{
    std::string str = R"(
/*
 * This stub is generated by jrpc, DO NOT modify it!
 */

#ifndef JRPC_[macroName]_H
#define JRPC_[macroName]_H

#include <jackson/Value.h>

#include <jrpc/util.h>
#include <jrpc/client/BaseClient.h>

namespace jrpc
{

class [stubClassName]: noncopyable
{
public:
    [stubClassName](EventLoop* loop, const InetAddress& serverAddress):
            client_(loop, serverAddress)
    {
        client_.setConnectionCallback([this](const TcpConnectionPtr& conn){
            if (conn->connected()) {
                INFO("connected");
                conn_ = conn;
                cb_(conn_);
            }
            else {
                INFO("disconnected");
                assert(conn_ != nullptr);
                cb_(conn_);
            }
        });
    }

    ~[stubClassName]() = default;

    void start() { client_.start(); }

    void setConnectionCallback(const ConnectionCallback& cb)
    {
        cb_ = cb;
    }

    [procedureDefinitions]
    [notifyDefinitions]

private:
    TcpConnectionPtr conn_;
    ConnectionCallback cb_;
    BaseClient client_;
};

}
#endif //JRPC_[macroName]_H
)";
    replaceAll(str, "[macroName]", macroName);
    replaceAll(str, "[stubClassName]", stubClassName);
    replaceAll(str, "[procedureDefinitions]", procedureDefinitions);
    replaceAll(str, "[notifyDefinitions]", notifyDefinitions);
    return str;
}


std::string procedureDefineTemplate(
        const std::string& serviceName,
        const std::string& procedureName,
        const std::string& procedureArgs,
        const std::string& paramMembers)
{
    std::string str = R"(
void [procedureName]([procedureArgs] const ResponseCallback& cb)
{
    json::Value params(json::TYPE_OBJECT);
    [paramMembers]

    json::Value call(json::TYPE_OBJECT);
    call.addMember("jsonrpc", "2.0");
    call.addMember("method", "[serviceName].[procedureName]");
    call.addMember("params", params);

    assert(conn_ != nullptr);
    client_.sendCall(conn_, call, cb);
}
)";
    replaceAll(str, "[serviceName]", serviceName);
    replaceAll(str, "[procedureName]", procedureName);
    replaceAll(str, "[procedureArgs]", procedureArgs);
    replaceAll(str, "[paramMembers]", paramMembers);
    return str;
}

std::string notifyDefineTemplate(
        const std::string& serviceName,
        const std::string& notifyName,
        const std::string& notifyArgs,
        const std::string& paramMembers)
{
    std::string str = R"(
void [notifyName]([notifyArgs])
{
    json::Value params(json::TYPE_OBJECT);
    [paramMembers]

    json::Value notify(json::TYPE_OBJECT);
    notify.addMember("jsonrpc", "2.0");
    notify.addMember("method", "Hello.Goodbye");

    assert(conn_ != nullptr);
    client_.sendNotify(conn_, notify);
}
)";
    replaceAll(str, "[serviceName]", serviceName);
    replaceAll(str, "[notifyName]", notifyName);
    replaceAll(str, "[notifyArgs]", notifyArgs);
    replaceAll(str, "[paramMembers]", paramMembers);
    return str;
}

std::string paramMemberTemplate(const std::string& paramName)
{
    std::string str = R"(
params.addMember("[paramName]", [paramName]);
)";
    replaceAll(str, "[paramName]", paramName);
    return str;
}

std::string argTemplate(
        const std::string& argName,
        json::ValueType argType)
{
    std::string str = R"([argType] [argName])";
    auto typeStr = [=](){
        switch (argType) {
            case json::TYPE_INT32:
                return "int32_t";
            case json::TYPE_INT64:
                return "int64_t";
            case json::TYPE_DOUBLE:
                return "double";
            case json::TYPE_BOOL:
                return "bool";
            case json::TYPE_STRING:
                return "std::string";
            case json::TYPE_OBJECT:
            case json::TYPE_ARRAY:
                return "json::Value";
            default:
                assert(false && "bad arg type");
                return "bad type";
        }
    }();
    replaceAll(str, "[argType]", typeStr);
    replaceAll(str, "[argName]", argName);
    return str;
}

}

std::string ClientStubGenerator::genStub()
{
    auto macroName = genMacroName();
    auto stubClassName = genStubClassName();
    auto procedureDefinitions = genProcedureDefinitions();
    auto notifyDefinitions = genNotifyDefinitions();

    return clientStubTemplate(macroName,
                              stubClassName,
                              procedureDefinitions,
                              notifyDefinitions);
}

std::string ClientStubGenerator::genMacroName()
{
    std::string result = serviceInfo_.name;
    for (char& c: result)
        c = static_cast<char>(toupper(c));
    return result + "CLIENTSTUB";
}

std::string ClientStubGenerator::genStubClassName()
{
    return serviceInfo_.name + "ClientStub";
}

std::string ClientStubGenerator::genProcedureDefinitions()
{
    std::string result;

    auto& serviceName = serviceInfo_.name;

    for (auto& r: serviceInfo_.rpcReturn) {
        auto& procedureName = r.name;
        auto  procedureArgs = genGenericArgs(r, true);
        auto  paramMembers = genGenericParamMembers(r);

        auto str = procedureDefineTemplate(
                serviceName,
                procedureName,
                procedureArgs,
                paramMembers);
        result.append(str);
    }
    return result;
}

std::string ClientStubGenerator::genNotifyDefinitions()
{
    std::string result;

    auto& serviceName = serviceInfo_.name;

    for (auto& r: serviceInfo_.rpcNotify) {
        auto& notifyName = r.name;
        auto notifyArgs = genGenericArgs(r, false);
        auto paramMembers = genGenericParamMembers(r);

        auto str = notifyDefineTemplate(
                serviceName,
                notifyName,
                notifyArgs,
                paramMembers);
        result.append(str);
    }
    return result;
}

template <typename Rpc>
std::string ClientStubGenerator::genGenericArgs(const Rpc& r, bool appendComma)
{
    std::string result;
    bool first = true;
    for (auto& p: r.params.getObject()) {
        std::string one = argTemplate(p.key.getString(),
                                      p.value.getType());
        if (first) {
            first = false;
        }
        else {
            result.append(", ");
        }
        result.append(one);
    }
    if (appendComma && !first)
        result.append(",");
    return result;
}

template <typename Rpc>
std::string ClientStubGenerator::genGenericParamMembers(const Rpc& r)
{
    std::string result;
    for (auto& p: r.params.getObject()) {
        std::string one = paramMemberTemplate(
                p.key.getString());
        result.append(one);
    }
    return result;
}